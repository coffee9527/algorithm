package top.pancras.算法第四版.sort;

/**
 * Created by pancras on 2018/5/3 0003.
 *
 * 快速排序
 *      快速排序可能是应用最广泛的排序算法了。快速排序流行的原因是它实现简单、适用于各种不同的输入数据且在一般应用中
 *  比其它排序算法都要快得多。快速排序引人注目的特点包括它是原地排序（只需要一个很小的辅助栈），且将长度为N的数组排序
 *  所需的时间NlogN成正比。我们已经学习过的排序算法都无法将两个优点结合起来。另外，快速排序的内循环比大多数排序算法都
 *  要短小，这意味着它无论是理论上还是在实际中都要更快。它的主要缺点是非常脆弱，在实现时要非常小心才能避免低劣的性能。
 *  已经有无数例子显示许多种错误都能致使它在实际中的性能只有平方级别。
 *
 *      快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快速排序和归并排序时互补的：归并
 *  排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组
 *  都有序时整个数组也就自然有序了。在第一种情况中，递归调用发生在处理整个数组之前；在第二种情况中，递归调用发生在处理
 *  整个数组之后。在归并排序中，一个数组被等分为两半；在快速排序中，切分(partition)的位置取决于数组的内容。
 *
 *
 *  快速排序的改进
 *      虽然快速排序已经很快啦，但是大佬们依然想到了很多改进的方式
 *          1.切换到插入排序
 *              原因：
 *              （1）对于小数组，快速排序比插入排序慢
 *              （2）因为递归，快速排序的sort()方法在小数组中也会调用自身
 *              代码：
 *                  将sort()中的语句
 *                  if(hi <= lo) return;
 *                  替换成
 *                  if(hi <= lo + M) {
 *                      new Sort2_Insection().sort(a, lo, hi);
 *                      return;
 *                  }
 *                  其中M是和系统系统相关的，一般5-15都可以
 *
 *            2.三取样切分
 *
 *
 *            3.熵最优排序(三向切分)
 *                  具体参考类 Sort7_Quick3Way
 */
public class Sort6_Quick extends SortTemplate {
    private Sort6_Quick() {}

    public static void sort(Comparable[] a) {
        //TODO 消除对输入的依赖 StdRandom.shuffle(a);

        sort(a, 0, a.length - 1);
    }

    private static void sort(Comparable[] a, int lo, int hi) {
        if(hi <= lo)
            return;
        int j = partition(a, lo, hi);   //切分
        sort(a, lo, j-1);           //将左半部分a[lo..j-1]排序
        sort(a, j+1, hi);           //将右半部分a[j+1..hi]排序
    }

    /**
     *  sort(Comparable[] a, int lo, int hi)方法的关键在于切分(partition)方法，这个过程使得数组满足下面三个条件：
     *  1.对于某个j,a[j]已经排定
     *  a[lo]到a[j-1]中的所有元素都不大于a[j];
     *  a[j+1]到a[hi]中的所有元素都不小于a[j]
     *      我们就是通过递归地调用来排序的。
     *      因为切人过程总是能排定一个元素，用递归法不难证明递归能够正确的将数组排序：如果子数组和右子数组(有序且没有任何
     *  元素小于切人元素)组成的结果数组也一定时有序的。sort方法就是实现了这个思路的一个递归程序。它是一个随机化的算法，因为
     *  它在将数组排序之前会将其随机打乱。我们这么做的原因是希望能够预测(并依赖)该算法的性能特性。
     *      要完成这个实现，需要切人方法。一般策略时先随意地取a[lo]作为切分元素，即那个将会被排定的元素，然后我们从数组的左端
     *  开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素。这两个元素显然是没有
     *  排定的，因此我们交换它们的位置。如此继续，我们就可以保证左指针I的左侧元素都不大于切分元素，右指针j的右侧元素都不小于切分
     *  元素。当两个指针相遇时，我们只需要将切分元素a[lo]和左子数组最右侧的元素(a[j])交换然后返回j即可。
     *
     *      partition方法按照a[lo]的值v进行切分。当指针i和j相遇时主循环退出。在循环中，a[i]小于v时我们增大i，a[j]大于v时我们减小
     *  j，然后交换a[i]和a[j]来保证i左侧的元素都不大于v，j右侧的元素都不小于v。当指针相遇时交换a[lo]和a[j],切分结束(这样切分值就
     *  留在a[j]中了)
     * @param a
     * @param lo
     * @param hi
     * @return
     */
    private static int partition(Comparable[] a, int lo, int hi) {
        //将数组切人为a[lo..i-1],a[i],a[i+1..hi]
        int i = lo, j = hi + 1;     //左右扫描指针
        Comparable v = a[lo];       //切人元素
        while (true) {
            //扫描左右，检查扫描是否结束并交换元素
            while(less(a[++i], v))
                if (i == hi)
                    break;
            while (less(v, a[--j]))
                if (j == lo)
                    break;
            if(i >= j)
                break;
            exch(a, i, j);
        }
        exch(a, lo, j);             //将v=a[j]放入正确的位置
        return j;                   //a[lo..j-1] <= a[j] <= a[j+1..hi]达成
    }
}
