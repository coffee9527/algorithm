package top.pancras.算法第四版.sort;

/**
 * Created by pancras on 2018/5/2 0002.
 *
 * 希尔排序
 *
 *      对于大规模乱序数组 插入排序 很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另一端。
 *  例如，如果主键最小的元素正好在数组的尽头，需要将它挪到正确的位置就需要N-1次移动。希尔排序为了加快速度简单的改进
 *  了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。
 *      希尔排序的思想是使数组中任意间隔为h的元素是有序的。这样的数组被称为h有序数组。换句话说，一个h有序数组就是h个
 *   互相独立的有序数组编制在一起组成的一个数组。在进行排序时，如果h很大，我们就能将元素移动到很远的地方，为实现更
 *   小的h有序创造方便。用这种方式，对于任意以1结尾的h序列，我们都能够将数组排序。这就是希尔排序。本类算法的实现使用了
 *   序列1/2(3^k-1),从N/3开始递减至1.我们把这个序列成为递增序列。
 */
public class Sort3_Shell extends SortTemplate {
    private Sort3_Shell() {}
    public static void sort(Comparable[] a) {
        //将a[]按升序排序
        int N = a.length;
        int h = 1;
        /**
         * 为啥下面while循环的条件的是h<N/3，而不是h<N/2,h<N/4，因为N/3是通过数学公式推导
         * 出来的，这种情况是普遍效率最快的
         */
        while(h<N/3) h = 3*h + 1;//1, 4, 13, 40, 121, 364, 1093, ...
        while (h >=1) {
            //将数组变为h有序
            for(int i = h; i < N; i++) {
                //将a[i]插入到a[i-h],a[i-2*h],a[i-3*h]...之中
                for (int j = i; j >= h && less(a[j], a[j-h]); j -= h)
                    exch(a, j, j-h);
            }
            h = h/3;
        }
    }
}
